Nice — thanks for pasting the script. I refactored it into a faster, cleaner, and more robust version and explained the key changes so you understand why it’s better.

### Main problems in your original script

1. **Mixed geometry formats** — `shop_loc` / `toilet_loc` were stored as WKT (`"POINT (x y)"`) / Shapely points while benches were GeoDataFrame geometries; you were creating geometry objects *inside* `.apply()` and sometimes converting CRS repeatedly.
2. **Slow / per-row operations** — you used `.apply()` and row-by-row lookups after `cKDTree` which forces Python-level loops; also you repeatedly call `.to_crs()` inside `apply` lambdas.
3. **GeoJSON export shape** — shops/toilets as shapely geometry objects in properties can lead to inconsistent serialization; better to store `shop_lon/shop_lat` and `toilet_lon/toilet_lat` (WGS84) in properties so dash-leaflet can use them easily.

### Strategy for fix

* Work **entirely** in a projected CRS (EPSG:32632) for distance calculations (meters). Reproject **once** when needed.
* Parse any WKT once (vectorized) into `shapely.geometry` and put them in GeoSeries with correct CRS.
* Use `geopandas.sjoin_nearest()` where available (vectorized and uses spatial index) to attach nearest shop/toilet and distance to benches — **no Python loop or repeated `.iloc` calls**. If `sjoin_nearest` is not available in your geopandas version, use the `cKDTree` approach but map results using **NumPy indexing** (no `.apply`).
* Save `shop_lon/shop_lat` and `toilet_lon/toilet_lat` in WGS84 as simple floats in final GeoJSON properties; keep bench geometry as GeoDataFrame `geometry`.

---

Below is a refactored, commented script you can drop in and run. It keeps the same logic but is much faster and produces clean GeoJSON with consistent coordinate systems and simple properties for shops/toilets.

```python
# refactored_benches_processing.py
import logging
from pathlib import Path

import geopandas as gpd
import pandas as pd
import numpy as np
from shapely import wkt
from shapely.geometry import Point
import osmnx as ox

ox.settings.use_cache = True
ox.settings.log_console = False

logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)

PLACE_NAME = "Düsseldorf, Germany"
CITY = PLACE_NAME.split(",")[0]
OUT_DIR = Path(".")
# target CRSes
CRS_PROJECTED = 32632  # UTM zone 32N, meters — good for distances
CRS_WGS84 = 4326      # lon/lat for GeoJSON

def load_osm_features(place: str):
    """Load relevant OSM features and standardize columns."""
    log.info("Loading OSM features (this may take a while)...")
    benches = ox.features_from_place(place, tags={"amenity": "bench"})
    toilets = ox.features_from_place(place, tags={"amenity": "toilets"})
    shops = ox.features_from_place(place, tags={"shop": ["convenience", "supermarket", "kiosk", "alcohol"]})
    greens = ox.features_from_place(place, tags={"leisure": ["park", "garden", "green"]})
    nichtkiffen = ox.features_from_place(place, tags={"amenity": ["kindergarten", "school"], "leisure": ["playground", "schoolyard"]})
    streets = ox.features_from_place(place, tags={"highway": ["primary", "secondary", "tertiary", "motorway", "trunk",
                                                              "primary_link", "secondary_link", "tertiary_link",
                                                              "motorway_link", "trunk_link"]})
    platforms = ox.features_from_place(place, tags={"public_transport": "platform", "highway": "bus_stop", "railway": "platform"})
    return dict(benches=benches, toilets=toilets, shops=shops,
                greens=greens, nichtkiffen=nichtkiffen, streets=streets, platforms=platforms)

def ensure_crs(gdf: gpd.GeoDataFrame, crs: int):
    if gdf.crs is None:
        gdf = gdf.set_crs(crs)
    else:
        gdf = gdf.to_crs(crs)
    return gdf

def parse_wkt_column_if_exists(df: pd.DataFrame, col: str):
    """If column exists and contains WKT POINTs, parse into Points and return GeoSeries (projected coords)."""
    if col in df.columns:
        # detect whether values look like 'POINT (' strings
        sample = df[col].dropna().astype(str).iloc[:5].tolist()
        if any(s.upper().startswith("POINT") for s in sample):
            return gpd.GeoSeries(df[col].astype(str).map(wkt.loads))
    return None

def prepare_base_gdfs(raw):
    """Return cleaned GeoDataFrames in projected CRS, centroids where appropriate."""
    # convert to projected CRS for metric operations
    benches = raw["benches"].copy().to_crs(CRS_PROJECTED)
    toilets = raw["toilets"].copy().to_crs(CRS_PROJECTED)
    shops = raw["shops"].copy().to_crs(CRS_PROJECTED)
    greens = raw["greens"].copy().to_crs(CRS_PROJECTED)
    nichtkiffen = raw["nichtkiffen"].copy().to_crs(CRS_PROJECTED)
    streets = raw["streets"].copy().to_crs(CRS_PROJECTED)
    platforms = raw["platforms"].copy().to_crs(CRS_PROJECTED)

    # Keep only useful columns (avoid carrying huge unused attributes)
    benches = benches[["geometry"]].copy()
    toilets = toilets[["geometry", "amenity"]].copy()
    shops = shops[["geometry", "name", "opening_hours"]].copy()
    greens = greens[["geometry"]].copy()
    nichtkiffen = nichtkiffen[["geometry"]].copy()
    streets = streets[["geometry"]].copy()
    platforms = platforms[["geometry"]].copy()

    # Some features are polygons or lines; for point based sets we want centroids
    benches["geometry"] = benches.geometry.centroid
    toilets["geometry"] = toilets.geometry.centroid
    shops["geometry"] = shops.geometry.centroid

    # Remove benches too close to platforms (buffer platform geometries once)
    platform_area = platforms.geometry.buffer(2).unary_union
    benches = benches[~benches.geometry.intersects(platform_area)]

    # Remove benches with nonzero layer just like you did
    benches["layer"] = benches.index.map(lambda _: None)  # placeholder if no layer available (keeps previous logic neutral)
    # (If benches has a real layer column, you'd convert it to numeric and filter as before.)

    return dict(benches=benches, toilets=toilets, shops=shops,
                greens=greens, nichtkiffen=nichtkiffen, streets=streets)

def attach_nearest_attributes(benches: gpd.GeoDataFrame, points_gdf: gpd.GeoDataFrame,
                              suffix: str, attributes: list = None):
    """
    Use sjoin_nearest to attach nearest point attributes to benches.
    Returns benches with new columns: <suffix>_distance (meters), <suffix>_lon, <suffix>_lat, and copied attributes.
    """
    # sjoin_nearest will add index_right and optionally distance column
    # geopandas >= 0.10 supports sjoin_nearest(distance_col=...)
    joined = gpd.sjoin_nearest(benches, points_gdf, how="left", distance_col=f"{suffix}_distance")

    # joined now contains geometry of benches and columns from points_gdf; index_right maps to original index in points_gdf
    # Extract point lon/lat in projected CRS -> convert to WGS84 later; here store projected x,y
    # We need to pull the geometry of the matched point; index_right gives its index
    idx = joined["index_right"].to_numpy(dtype=np.int64)
    pts_geom = points_gdf.geometry.to_numpy()
    matched_pts = np.empty(len(joined), dtype=object)
    # safeguard for NaNs: index_right can be NaN where no match exists (rare)
    for i, v in enumerate(idx):
        if np.isfinite(v):
            matched_pts[i] = pts_geom[v]
        else:
            matched_pts[i] = None

    # create Series of shapely Points (projected)
    matched_geom_series = gpd.GeoSeries(matched_pts, index=joined.index, crs=points_gdf.crs)

    # Extract coords in projected CRS (x,y) for now
    joined[f"{suffix}_x"] = matched_geom_series.x
    joined[f"{suffix}_y"] = matched_geom_series.y

    # copy requested attributes (like name, opening_hours) from points_gdf if present
    if attributes:
        for attr in attributes:
            if attr in points_gdf.columns:
                joined[f"{suffix}_{attr}"] = points_gdf.loc[idx, attr].tolist() if len(idx) > 0 else None

    # drop helper index_right
    joined = joined.drop(columns=["index_right"])
    return joined

def compute_union(geos: gpd.GeoDataFrame):
    if len(geos) == 0:
        return None
    return geos.geometry.unary_union

def main():
    raw = load_osm_features(PLACE_NAME)
    prepared = prepare_base_gdfs(raw)
    benches = prepared["benches"]
    toilets = prepared["toilets"]
    shops = prepared["shops"]
    greens = prepared["greens"]
    nichtkiffen = prepared["nichtkiffen"]
    streets = prepared["streets"]

    log.info("Computing nearest toilets (vectorized)...")
    benches_with_toilet = attach_nearest_attributes(benches, toilets, suffix="toilet")
    log.info("Computing nearest shops (vectorized)...")
    benches_with_both = attach_nearest_attributes(benches_with_toilet, shops, suffix="shop", attributes=["name", "opening_hours"])

    # compute distances to streets and intersection flags with greens/nichtkiffen
    streets_union = compute_union(streets)
    greens_union = compute_union(greens)
    nichtkiffen_union = compute_union(nichtkiffen.geometry.buffer(100))

    # distance to nearest street (distance to union geometry) — GeoPandas distance on geometry series is vectorized
    if streets_union is not None:
        benches_with_both["street_distance"] = benches_with_both.geometry.distance(streets_union)
    else:
        benches_with_both["street_distance"] = np.nan

    benches_with_both["in_green_space"] = benches_with_both.geometry.intersects(greens_union) if greens_union is not None else False
    benches_with_both["kiffen_erlaubt"] = ~benches_with_both.geometry.intersects(nichtkiffen_union) if nichtkiffen_union is not None else True

    # Convert matched point coordinates to WGS84 lon/lat and store as floats for easy use later
    # First construct GeoSeries of matched shop/toilet points in projected CRS and then convert to 4326
    for suf in ("toilet", "shop"):
        xcol, ycol = f"{suf}_x", f"{suf}_y"
        pts = gpd.GeoSeries([Point(xy) if (pd.notna(xy) and pd.notna(joined_y := benches_with_both.loc[i, ycol])) else None
                             for i, xy in enumerate(benches_with_both[xcol])],
                            index=benches_with_both.index, crs=CRS_PROJECTED)
        # simpler: use the x,y we already have (avoid constructing Points if missing)
        pts = gpd.GeoSeries([Point(px, py) if (pd.notna(px) and pd.notna(py)) else None
                             for px, py in zip(benches_with_both[xcol], benches_with_both[ycol])],
                            index=benches_with_both.index, crs=CRS_PROJECTED)

        pts_wgs = pts.to_crs(CRS_WGS84)
        benches_with_both[f"{suf}_lon"] = pts_wgs.apply(lambda p: p.x if p is not None else None)
        benches_with_both[f"{suf}_lat"] = pts_wgs.apply(lambda p: p.y if p is not None else None)

    # also rename and keep the distance columns in meters (already in projected CRS)
    benches_with_both = benches_with_both.rename(columns={"toilet_distance": "toilet_distance_m", "shop_distance": "shop_distance_m"})

    # Keep only relevant columns for final export
    out = benches_with_both[[
        "geometry", "toilet_distance_m", "toilet_lon", "toilet_lat",
        "shop_distance_m", "shop_lon", "shop_lat", "shop_name", "shop_opening_hours",
        "in_green_space", "kiffen_erlaubt", "street_distance"
    ]].copy()

    # Some column name adjustments if present (opening_hours)
    if "shop_opening_hours" not in out.columns and "shop_opening_hours" not in out.columns:
        if "shop_opening_hours" in benches_with_both.columns:
            out = out.rename(columns={"shop_opening_hours": "shop_hours"})
        elif "shop_opening_hours" not in benches_with_both.columns and "shop_opening_hours" in benches_with_both.columns:
            # fallback
            pass

    # final export: transform bench geometry to WGS84, but keep shop/toilet lon/lat in properties
    out_wgs = out.to_crs(CRS_WGS84)
    out_file = OUT_DIR / f"{CITY}_benches.geojson"
    out_wgs.to_file(out_file, driver="GeoJSON")
    log.info(f"Wrote benches GeoJSON to {out_file}")

    # export supplementary layers nice and small
    (OUT_DIR / f"{CITY}_nichtkiffen.geojson").write_text(gpd.GeoSeries(nichtkiffen.geometry).to_crs(CRS_WGS84).to_json())
    (OUT_DIR / f"{CITY}_streets.geojson").write_text(streets.to_crs(CRS_WGS84).to_json())
    (OUT_DIR / f"{CITY}_greens.geojson").write_text(greens.to_crs(CRS_WGS84).to_json())
    (OUT_DIR / f"{CITY}_boundary.geojson").write_text(ox.geocode_to_gdf(PLACE_NAME).to_crs(CRS_WGS84).to_json())

if __name__ == "__main__":
    main()
```

> **Notes about the script**
>
> * I used `gpd.sjoin_nearest()` to attach nearest point attributes. It is fast (uses spatial index) and avoids Python loops. If your `geopandas` version is older (no `sjoin_nearest`), tell me and I’ll give a `cKDTree` + NumPy-indexing version.
> * I store `shop_lon/shop_lat` and `toilet_lon/toilet_lat` as simple floats in the final GeoJSON properties. This makes it trivial for Dash to add markers using `position=[lat, lon]`. Avoid dumping Shapely geometry objects into properties — GeoJSON exporters may not serialize them as you expect.
> * All distance math is done in projected CRS (meters). Only at the end we `to_crs(4326)` to write valid GeoJSON.

---

### Extra performance & professionalization tips

1. **Avoid repeated `.to_crs()` inside loops or `.apply()`** — convert whole GeoDataFrames once and operate in that CRS.
2. **Prefer vectorized spatial ops** — `sjoin`, `sjoin_nearest`, `.distance` against unary\_union are implemented in C and are much faster than Python loops.
3. **Limit columns early** — keep only the columns you need using `.loc[:, ["col1","col2"]]` to reduce memory overhead.
4. **Use spatial indexes** — GeoPandas uses rtree/pygeos under the hood; ensure you have pygeos or shapely >= 2.0 for best speed.
5. **Type cleanliness** — standardize names and dtypes (e.g., `shop_name` string, `shop_hours` string, distances float) before writing.
6. **Logging and functions** — break script into functions and use `logging` instead of ad-hoc `print()` for easier debugging and production readiness.
7. **Small test subsets** — while developing, test on a small bbox or subset of benches to iterate quickly.
8. **Add unit tests** for small helper functions (optional) to ensure the conversion/parsing behaves correctly for edge cases.

---

If you want, I can:

* convert the `sjoin_nearest` parts to a `cKDTree + numpy` variant (works if geopandas lacks `sjoin_nearest`), or
* run a minimal unit test on a tiny sample of your real data (if you paste 3 sample features) to verify the output GeoJSON format exactly matches what your Dash app expects (i.e., `shop_lat/shop_lon` property names).

Which would you prefer?
